"""Motion vector manipulation using FFglitch.

This module uses FFglitch tools (ffedit, ffgac) to manipulate motion vectors
for advanced datamoshing effects. FFglitch uses JavaScript scripting to
transform frame data during video processing.

FFglitch 0.10.x Workflow:
1. Prepare video for processing (convert to compatible codec if needed)
2. Generate a JavaScript script that transforms motion vectors
3. Run ffedit with the script to process the video
4. Re-encode the output for compatibility

The JavaScript scripts have access to frame data including:
- mv: Motion vectors (forward and backward)
- mv_delta: Motion vector deltas
- fwd_mvs/back_mvs: Forward/backward motion vector arrays
"""

import json
import subprocess
import tempfile
from pathlib import Path
from textwrap import dedent
from typing import Callable

import numpy as np

from moshpit.io.video import PreviewSettings, get_video_info

# Type alias for vector transform functions
VectorTransform = Callable[[np.ndarray, int, dict], np.ndarray]


def check_ffglitch_installed() -> bool:
    """Check if FFglitch tools are available."""
    try:
        # FFglitch tools use -version (single dash)
        result = subprocess.run(
            ["ffedit", "-version"], capture_output=True, text=True
        )
        # ffedit returns version info even on "error" exit codes
        if "ffedit" not in result.stdout and "ffedit" not in result.stderr:
            return False
        result = subprocess.run(
            ["ffgac", "-version"], capture_output=True, text=True
        )
        if "ffgac" not in result.stdout and "ffgac" not in result.stderr:
            return False
        return True
    except FileNotFoundError:
        return False


def _generate_transform_script(
    transform_name: str,
    params: dict,
) -> str:
    """Generate a JavaScript script for FFglitch based on transform name.

    FFglitch scripts define functions that are called for each frame.
    The main entry points are:
    - glitch_frame(frame, stream): Called for each video frame
    - setup(): Called once at start

    Motion vectors are accessed via frame.mv or through specific properties.

    Args:
        transform_name: Name of the transform to apply
        params: Parameters for the transform

    Returns:
        JavaScript code as a string
    """
    # Extract common parameters
    strength = params.get("strength", 0.5)
    factor = params.get("factor", 2.0)
    freq = params.get("freq", 0.1)
    amp = params.get("amp", 5.0)
    axis = params.get("axis", "both")
    seed = params.get("seed", 42)

    # Base script template with helper functions
    base_script = dedent(f'''
        // FFglitch motion vector manipulation script
        // Generated by moshpit

        var frame_count = 0;
        var seed = {seed};

        // Simple seeded random number generator
        function random() {{
            seed = (seed * 1103515245 + 12345) & 0x7fffffff;
            return (seed / 0x7fffffff);
        }}

        function gaussian_random() {{
            // Box-Muller transform for gaussian distribution
            var u1 = random();
            var u2 = random();
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        }}

    ''')

    # Transform-specific scripts
    transform_scripts = {
        "jitter": dedent(f'''
            // Jitter: Add random noise to motion vectors
            var strength = {strength};

            export function glitch_frame(frame, stream) {{
                var dominated_vectors = frame["mv"];
                if (!dominated_vectors) return;

                for (var i = 0; i < dominated_vectors.length; i++) {{
                    var mb_row = dominated_vectors[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb) continue;

                        // Process forward motion vectors
                        if (mb["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length; k++) {{
                                var mv = mb["fwd"][k];
                                if (mv) {{
                                    mv[0] += Math.round(gaussian_random() * strength * 16);
                                    mv[1] += Math.round(gaussian_random() * strength * 16);
                                }}
                            }}
                        }}

                        // Process backward motion vectors
                        if (mb["bwd"]) {{
                            for (var k = 0; k < mb["bwd"].length; k++) {{
                                var mv = mb["bwd"][k];
                                if (mv) {{
                                    mv[0] += Math.round(gaussian_random() * strength * 16);
                                    mv[1] += Math.round(gaussian_random() * strength * 16);
                                }}
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),

        "amplify": dedent(f'''
            // Amplify: Scale motion vectors by a factor
            var factor = {factor};

            export function glitch_frame(frame, stream) {{
                var dominated_vectors = frame["mv"];
                if (!dominated_vectors) return;

                for (var i = 0; i < dominated_vectors.length; i++) {{
                    var mb_row = dominated_vectors[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb) continue;

                        if (mb["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length; k++) {{
                                var mv = mb["fwd"][k];
                                if (mv) {{
                                    mv[0] = Math.round(mv[0] * factor);
                                    mv[1] = Math.round(mv[1] * factor);
                                }}
                            }}
                        }}

                        if (mb["bwd"]) {{
                            for (var k = 0; k < mb["bwd"].length; k++) {{
                                var mv = mb["bwd"][k];
                                if (mv) {{
                                    mv[0] = Math.round(mv[0] * factor);
                                    mv[1] = Math.round(mv[1] * factor);
                                }}
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),

        "horizontal-kill": dedent('''
            // Horizontal Kill: Zero out horizontal motion
            export function glitch_frame(frame, stream) {
                var dominated_vectors = frame["mv"];
                if (!dominated_vectors) return;

                for (var i = 0; i < dominated_vectors.length; i++) {
                    var mb_row = dominated_vectors[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {
                        var mb = mb_row[j];
                        if (!mb) continue;

                        if (mb["fwd"]) {
                            for (var k = 0; k < mb["fwd"].length; k++) {
                                var mv = mb["fwd"][k];
                                if (mv) mv[0] = 0;
                            }
                        }

                        if (mb["bwd"]) {
                            for (var k = 0; k < mb["bwd"].length; k++) {
                                var mv = mb["bwd"][k];
                                if (mv) mv[0] = 0;
                            }
                        }
                    }
                }
                frame_count++;
            }
        '''),

        "vertical-kill": dedent('''
            // Vertical Kill: Zero out vertical motion
            export function glitch_frame(frame, stream) {
                var dominated_vectors = frame["mv"];
                if (!dominated_vectors) return;

                for (var i = 0; i < dominated_vectors.length; i++) {
                    var mb_row = dominated_vectors[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {
                        var mb = mb_row[j];
                        if (!mb) continue;

                        if (mb["fwd"]) {
                            for (var k = 0; k < mb["fwd"].length; k++) {
                                var mv = mb["fwd"][k];
                                if (mv) mv[1] = 0;
                            }
                        }

                        if (mb["bwd"]) {
                            for (var k = 0; k < mb["bwd"].length; k++) {
                                var mv = mb["bwd"][k];
                                if (mv) mv[1] = 0;
                            }
                        }
                    }
                }
                frame_count++;
            }
        '''),

        "invert": dedent(f'''
            // Invert: Flip motion direction
            var axis = "{axis}";

            export function glitch_frame(frame, stream) {{
                var dominated_vectors = frame["mv"];
                if (!dominated_vectors) return;

                for (var i = 0; i < dominated_vectors.length; i++) {{
                    var mb_row = dominated_vectors[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb) continue;

                        if (mb["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length; k++) {{
                                var mv = mb["fwd"][k];
                                if (mv) {{
                                    if (axis === "x" || axis === "both") mv[0] = -mv[0];
                                    if (axis === "y" || axis === "both") mv[1] = -mv[1];
                                }}
                            }}
                        }}

                        if (mb["bwd"]) {{
                            for (var k = 0; k < mb["bwd"].length; k++) {{
                                var mv = mb["bwd"][k];
                                if (mv) {{
                                    if (axis === "x" || axis === "both") mv[0] = -mv[0];
                                    if (axis === "y" || axis === "both") mv[1] = -mv[1];
                                }}
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),

        "swap-axes": dedent('''
            // Swap Axes: Exchange horizontal and vertical motion
            export function glitch_frame(frame, stream) {
                var dominated_vectors = frame["mv"];
                if (!dominated_vectors) return;

                for (var i = 0; i < dominated_vectors.length; i++) {
                    var mb_row = dominated_vectors[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {
                        var mb = mb_row[j];
                        if (!mb) continue;

                        if (mb["fwd"]) {
                            for (var k = 0; k < mb["fwd"].length; k++) {
                                var mv = mb["fwd"][k];
                                if (mv) {
                                    var tmp = mv[0];
                                    mv[0] = mv[1];
                                    mv[1] = tmp;
                                }
                            }
                        }

                        if (mb["bwd"]) {
                            for (var k = 0; k < mb["bwd"].length; k++) {
                                var mv = mb["bwd"][k];
                                if (mv) {
                                    var tmp = mv[0];
                                    mv[0] = mv[1];
                                    mv[1] = tmp;
                                }
                            }
                        }
                    }
                }
                frame_count++;
            }
        '''),

        "sine-wave": dedent(f'''
            // Sine Wave: Apply sinusoidal displacement
            var freq = {freq};
            var amp = {amp};
            var axis = "{axis}";

            export function glitch_frame(frame, stream) {{
                var dominated_vectors = frame["mv"];
                if (!dominated_vectors) return;

                for (var i = 0; i < dominated_vectors.length; i++) {{
                    var mb_row = dominated_vectors[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb) continue;

                        // Calculate displacement based on position
                        var displacement;
                        if (axis === "x") {{
                            displacement = Math.round(amp * Math.sin(2 * Math.PI * freq * i) * 16);
                        }} else {{
                            displacement = Math.round(amp * Math.sin(2 * Math.PI * freq * j) * 16);
                        }}

                        if (mb["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length; k++) {{
                                var mv = mb["fwd"][k];
                                if (mv) {{
                                    if (axis === "x") {{
                                        mv[0] += displacement;
                                    }} else {{
                                        mv[1] += displacement;
                                    }}
                                }}
                            }}
                        }}

                        if (mb["bwd"]) {{
                            for (var k = 0; k < mb["bwd"].length; k++) {{
                                var mv = mb["bwd"][k];
                                if (mv) {{
                                    if (axis === "x") {{
                                        mv[0] += displacement;
                                    }} else {{
                                        mv[1] += displacement;
                                    }}
                                }}
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),

        "quantize": dedent(f'''
            // Quantize: Posterize motion to discrete levels
            var levels = {params.get("levels", 4)};

            export function glitch_frame(frame, stream) {{
                var dominated_vectors = frame["mv"];
                if (!dominated_vectors) return;

                var step = Math.round(256 / levels);  // Motion vectors are typically in range

                for (var i = 0; i < dominated_vectors.length; i++) {{
                    var mb_row = dominated_vectors[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb) continue;

                        if (mb["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length; k++) {{
                                var mv = mb["fwd"][k];
                                if (mv) {{
                                    mv[0] = Math.round(mv[0] / step) * step;
                                    mv[1] = Math.round(mv[1] / step) * step;
                                }}
                            }}
                        }}

                        if (mb["bwd"]) {{
                            for (var k = 0; k < mb["bwd"].length; k++) {{
                                var mv = mb["bwd"][k];
                                if (mv) {{
                                    mv[0] = Math.round(mv[0] / step) * step;
                                    mv[1] = Math.round(mv[1] / step) * step;
                                }}
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),

        "blur": dedent(f'''
            // Blur: Average motion vectors with neighbors (spatial smoothing)
            var kernel = {params.get("kernel", 3)};
            var half_k = Math.floor(kernel / 2);

            export function glitch_frame(frame, stream) {{
                var mv = frame["mv"];
                if (!mv || mv.length === 0) return;

                // Create a copy of motion vectors for reading
                var original = JSON.parse(JSON.stringify(mv));

                for (var i = 0; i < mv.length; i++) {{
                    var mb_row = mv[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb || !mb["fwd"]) continue;

                        for (var k = 0; k < mb["fwd"].length; k++) {{
                            var sum_x = 0, sum_y = 0, count = 0;

                            // Average with neighbors
                            for (var di = -half_k; di <= half_k; di++) {{
                                for (var dj = -half_k; dj <= half_k; dj++) {{
                                    var ni = i + di;
                                    var nj = j + dj;
                                    if (ni >= 0 && ni < original.length &&
                                        original[ni] && nj >= 0 && nj < original[ni].length &&
                                        original[ni][nj] && original[ni][nj]["fwd"] &&
                                        original[ni][nj]["fwd"][k]) {{
                                        sum_x += original[ni][nj]["fwd"][k][0];
                                        sum_y += original[ni][nj]["fwd"][k][1];
                                        count++;
                                    }}
                                }}
                            }}

                            if (count > 0) {{
                                mb["fwd"][k][0] = Math.round(sum_x / count);
                                mb["fwd"][k][1] = Math.round(sum_y / count);
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),

        "threshold": dedent(f'''
            // Threshold: Binary threshold motion vectors
            var cutoff = {params.get("cutoff", 8)};
            var high_val = {params.get("high", 16)};
            var low_val = {params.get("low", 0)};

            export function glitch_frame(frame, stream) {{
                var mv = frame["mv"];
                if (!mv) return;

                for (var i = 0; i < mv.length; i++) {{
                    var mb_row = mv[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb) continue;

                        if (mb["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length; k++) {{
                                var vec = mb["fwd"][k];
                                if (vec) {{
                                    vec[0] = Math.abs(vec[0]) > cutoff ? (vec[0] > 0 ? high_val : -high_val) : low_val;
                                    vec[1] = Math.abs(vec[1]) > cutoff ? (vec[1] > 0 ? high_val : -high_val) : low_val;
                                }}
                            }}
                        }}

                        if (mb["bwd"]) {{
                            for (var k = 0; k < mb["bwd"].length; k++) {{
                                var vec = mb["bwd"][k];
                                if (vec) {{
                                    vec[0] = Math.abs(vec[0]) > cutoff ? (vec[0] > 0 ? high_val : -high_val) : low_val;
                                    vec[1] = Math.abs(vec[1]) > cutoff ? (vec[1] > 0 ? high_val : -high_val) : low_val;
                                }}
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),

        "uniform": dedent(f'''
            // Uniform: Add uniform random noise
            var strength = {params.get("strength", 1.0)};

            export function glitch_frame(frame, stream) {{
                var mv = frame["mv"];
                if (!mv) return;

                for (var i = 0; i < mv.length; i++) {{
                    var mb_row = mv[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb) continue;

                        if (mb["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length; k++) {{
                                var vec = mb["fwd"][k];
                                if (vec) {{
                                    vec[0] += Math.round((random() - 0.5) * 2 * strength * 16);
                                    vec[1] += Math.round((random() - 0.5) * 2 * strength * 16);
                                }}
                            }}
                        }}

                        if (mb["bwd"]) {{
                            for (var k = 0; k < mb["bwd"].length; k++) {{
                                var vec = mb["bwd"][k];
                                if (vec) {{
                                    vec[0] += Math.round((random() - 0.5) * 2 * strength * 16);
                                    vec[1] += Math.round((random() - 0.5) * 2 * strength * 16);
                                }}
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),

        "gaussian": dedent(f'''
            // Gaussian: Add Gaussian random noise
            var sigma = {params.get("sigma", 1.0)};

            export function glitch_frame(frame, stream) {{
                var mv = frame["mv"];
                if (!mv) return;

                for (var i = 0; i < mv.length; i++) {{
                    var mb_row = mv[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb) continue;

                        if (mb["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length; k++) {{
                                var vec = mb["fwd"][k];
                                if (vec) {{
                                    vec[0] += Math.round(gaussian_random() * sigma * 16);
                                    vec[1] += Math.round(gaussian_random() * sigma * 16);
                                }}
                            }}
                        }}

                        if (mb["bwd"]) {{
                            for (var k = 0; k < mb["bwd"].length; k++) {{
                                var vec = mb["bwd"][k];
                                if (vec) {{
                                    vec[0] += Math.round(gaussian_random() * sigma * 16);
                                    vec[1] += Math.round(gaussian_random() * sigma * 16);
                                }}
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),

        "feedback": dedent(f'''
            // Feedback: Blend with previous frame's vectors (temporal smoothing)
            var blend = {params.get("blend", 0.5)};
            var prev_mv = null;

            export function glitch_frame(frame, stream) {{
                var mv = frame["mv"];
                if (!mv) return;

                if (prev_mv === null) {{
                    // First frame, just store a copy
                    prev_mv = JSON.parse(JSON.stringify(mv));
                    return;
                }}

                for (var i = 0; i < mv.length && i < prev_mv.length; i++) {{
                    var mb_row = mv[i];
                    var prev_row = prev_mv[i];
                    if (!mb_row || !prev_row) continue;

                    for (var j = 0; j < mb_row.length && j < prev_row.length; j++) {{
                        var mb = mb_row[j];
                        var prev_mb = prev_row[j];
                        if (!mb || !prev_mb) continue;

                        if (mb["fwd"] && prev_mb["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length && k < prev_mb["fwd"].length; k++) {{
                                var vec = mb["fwd"][k];
                                var prev_vec = prev_mb["fwd"][k];
                                if (vec && prev_vec) {{
                                    vec[0] = Math.round((1 - blend) * vec[0] + blend * prev_vec[0]);
                                    vec[1] = Math.round((1 - blend) * vec[1] + blend * prev_vec[1]);
                                }}
                            }}
                        }}
                    }}
                }}

                // Store current for next frame
                prev_mv = JSON.parse(JSON.stringify(mv));
                frame_count++;
            }}
        '''),

        "accumulate": dedent(f'''
            // Accumulate: Sum vectors over time (creates motion trails)
            var decay = {params.get("decay", 0.9)};
            var accumulated = null;

            export function glitch_frame(frame, stream) {{
                var mv = frame["mv"];
                if (!mv) return;

                if (accumulated === null) {{
                    accumulated = JSON.parse(JSON.stringify(mv));
                    return;
                }}

                for (var i = 0; i < mv.length; i++) {{
                    var mb_row = mv[i];
                    if (!mb_row) continue;

                    // Ensure accumulated has this row
                    if (!accumulated[i]) {{
                        accumulated[i] = JSON.parse(JSON.stringify(mb_row));
                        continue;
                    }}

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb) continue;

                        if (!accumulated[i][j]) {{
                            accumulated[i][j] = JSON.parse(JSON.stringify(mb));
                            continue;
                        }}

                        if (mb["fwd"] && accumulated[i][j]["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length; k++) {{
                                var vec = mb["fwd"][k];
                                if (!accumulated[i][j]["fwd"][k]) {{
                                    accumulated[i][j]["fwd"][k] = [0, 0];
                                }}
                                var acc = accumulated[i][j]["fwd"][k];
                                if (vec && acc) {{
                                    // Decay old value and add new
                                    acc[0] = acc[0] * decay + vec[0];
                                    acc[1] = acc[1] * decay + vec[1];
                                    // Apply accumulated to current frame
                                    vec[0] = Math.round(acc[0]);
                                    vec[1] = Math.round(acc[1]);
                                }}
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),

        "spiral": dedent(f'''
            // Spiral: Apply radial spiral pattern
            var spiral_freq = {params.get("freq", 0.02)};
            var spiral_amp = {params.get("amp", 3.0)};

            export function glitch_frame(frame, stream) {{
                var mv = frame["mv"];
                if (!mv || mv.length === 0) return;

                var rows = mv.length;
                var cols = mv[0] ? mv[0].length : 0;
                var cy = rows / 2;
                var cx = cols / 2;

                for (var i = 0; i < mv.length; i++) {{
                    var mb_row = mv[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb) continue;

                        var r = Math.sqrt((j - cx) * (j - cx) + (i - cy) * (i - cy));
                        var displacement = Math.round(spiral_amp * Math.sin(r * spiral_freq * 2 * Math.PI) * 16);

                        if (mb["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length; k++) {{
                                var vec = mb["fwd"][k];
                                if (vec) {{
                                    vec[0] += displacement;
                                    vec[1] += displacement;
                                }}
                            }}
                        }}

                        if (mb["bwd"]) {{
                            for (var k = 0; k < mb["bwd"].length; k++) {{
                                var vec = mb["bwd"][k];
                                if (vec) {{
                                    vec[0] += displacement;
                                    vec[1] += displacement;
                                }}
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),

        "radial-gradient": dedent(f'''
            // Radial Gradient: Effect varies from center outward
            var inner = {params.get("inner_strength", 0.0)};
            var outer = {params.get("outer_strength", 2.0)};

            export function glitch_frame(frame, stream) {{
                var mv = frame["mv"];
                if (!mv || mv.length === 0) return;

                var rows = mv.length;
                var cols = mv[0] ? mv[0].length : 0;
                var cy = rows / 2;
                var cx = cols / 2;
                var max_r = Math.sqrt(cx * cx + cy * cy);

                for (var i = 0; i < mv.length; i++) {{
                    var mb_row = mv[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb) continue;

                        var r = Math.sqrt((j - cx) * (j - cx) + (i - cy) * (i - cy));
                        var t = r / max_r;
                        var strength = inner + t * (outer - inner);

                        if (mb["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length; k++) {{
                                var vec = mb["fwd"][k];
                                if (vec) {{
                                    vec[0] = Math.round(vec[0] * strength);
                                    vec[1] = Math.round(vec[1] * strength);
                                }}
                            }}
                        }}

                        if (mb["bwd"]) {{
                            for (var k = 0; k < mb["bwd"].length; k++) {{
                                var vec = mb["bwd"][k];
                                if (vec) {{
                                    vec[0] = Math.round(vec[0] * strength);
                                    vec[1] = Math.round(vec[1] * strength);
                                }}
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),

        "cosine-wave": dedent(f'''
            // Cosine Wave: Apply cosine wave displacement (90 degree phase shift from sine)
            var freq = {freq};
            var amp = {amp};
            var axis = "{axis}";

            export function glitch_frame(frame, stream) {{
                var mv = frame["mv"];
                if (!mv) return;

                for (var i = 0; i < mv.length; i++) {{
                    var mb_row = mv[i];
                    if (!mb_row) continue;

                    for (var j = 0; j < mb_row.length; j++) {{
                        var mb = mb_row[j];
                        if (!mb) continue;

                        var displacement;
                        if (axis === "x") {{
                            displacement = Math.round(amp * Math.cos(2 * Math.PI * freq * i) * 16);
                        }} else {{
                            displacement = Math.round(amp * Math.cos(2 * Math.PI * freq * j) * 16);
                        }}

                        if (mb["fwd"]) {{
                            for (var k = 0; k < mb["fwd"].length; k++) {{
                                var vec = mb["fwd"][k];
                                if (vec) {{
                                    if (axis === "x") {{
                                        vec[0] += displacement;
                                    }} else {{
                                        vec[1] += displacement;
                                    }}
                                }}
                            }}
                        }}

                        if (mb["bwd"]) {{
                            for (var k = 0; k < mb["bwd"].length; k++) {{
                                var vec = mb["bwd"][k];
                                if (vec) {{
                                    if (axis === "x") {{
                                        vec[0] += displacement;
                                    }} else {{
                                        vec[1] += displacement;
                                    }}
                                }}
                            }}
                        }}
                    }}
                }}
                frame_count++;
            }}
        '''),
    }

    # Get the transform script or default to jitter
    transform_code = transform_scripts.get(transform_name, transform_scripts["jitter"])

    return base_script + transform_code


def _generate_expression_script(expression: str) -> str:
    """Generate a JavaScript script from a Python-like expression.

    Converts simple expressions to JavaScript for FFglitch.

    Args:
        expression: Python-like expression for motion vector manipulation

    Returns:
        JavaScript code as a string
    """
    # Convert Python-style expressions to JavaScript
    # This is a simplified converter for common patterns
    js_expr = expression

    # Replace numpy-style indexing with JavaScript
    # frame[:,:,0] -> process all x components
    # frame[:,:,1] -> process all y components
    if "frame[:,:,0]" in js_expr:
        component = 0
        op_match = js_expr.split("frame[:,:,0]")[1].strip()
    elif "frame[:,:,1]" in js_expr:
        component = 1
        op_match = js_expr.split("frame[:,:,1]")[1].strip()
    else:
        component = -1  # Both components
        op_match = js_expr

    # Parse the operation
    if "*=" in op_match:
        factor = op_match.replace("*=", "").strip()
        operation = f"mv[{component if component >= 0 else 'c'}] = Math.round(mv[{component if component >= 0 else 'c'}] * {factor});"
    elif "+=" in op_match:
        addend = op_match.replace("+=", "").strip()
        operation = f"mv[{component if component >= 0 else 'c'}] += Math.round({addend});"
    elif "= 0" in op_match or "=0" in op_match:
        operation = f"mv[{component if component >= 0 else 'c'}] = 0;"
    else:
        # Default: try to use the expression directly
        operation = f"// Custom: {js_expr}"

    script = dedent(f'''
        // FFglitch script from expression: {expression}

        export function glitch_frame(frame, stream) {{
            var dominated_vectors = frame["mv"];
            if (!dominated_vectors) return;

            for (var i = 0; i < dominated_vectors.length; i++) {{
                var mb_row = dominated_vectors[i];
                if (!mb_row) continue;

                for (var j = 0; j < mb_row.length; j++) {{
                    var mb = mb_row[j];
                    if (!mb) continue;

                    if (mb["fwd"]) {{
                        for (var k = 0; k < mb["fwd"].length; k++) {{
                            var mv = mb["fwd"][k];
                            if (mv) {{
                                {"for (var c = 0; c < 2; c++) { " + operation + " }" if component < 0 else operation}
                            }}
                        }}
                    }}

                    if (mb["bwd"]) {{
                        for (var k = 0; k < mb["bwd"].length; k++) {{
                            var mv = mb["bwd"][k];
                            if (mv) {{
                                {"for (var c = 0; c < 2; c++) { " + operation + " }" if component < 0 else operation}
                            }}
                        }}
                    }}
                }}
            }}
        }}
    ''')

    return script


def _prepare_video_for_ffglitch(
    input_path: Path,
    output_path: Path,
    preview: PreviewSettings | None = None,
) -> Path:
    """Convert video to a codec compatible with FFglitch motion vector manipulation.

    FFglitch works best with MPEG-4 or MPEG-2 codecs for motion vector access.

    Args:
        input_path: Source video
        output_path: Destination for converted video
        preview: Optional preview settings for scaling

    Returns:
        Path to the prepared video
    """
    cmd = [
        "ffmpeg",
        "-y",
        "-i",
        str(input_path),
    ]

    if preview:
        cmd.extend(["-vf", preview.scale_filter])

    # Use MPEG-4 Part 2 which has good motion vector support in FFglitch
    cmd.extend([
        "-c:v",
        "mpeg4",
        "-q:v",
        "2",  # High quality
        "-an",  # Remove audio for processing (we'll add it back later)
        str(output_path),
    ])

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        raise RuntimeError(f"FFmpeg preparation failed: {result.stderr}")

    return output_path


def _run_ffglitch_script(
    input_path: Path,
    output_path: Path,
    script_path: Path,
) -> Path:
    """Run an FFglitch JavaScript script on a video.

    Uses ffedit to apply the motion vector transformation script.

    Args:
        input_path: Source video (should be MPEG-4 encoded)
        output_path: Output video path
        script_path: Path to JavaScript script file

    Returns:
        Path to the processed video
    """
    # ffedit command: ffedit -i input -f mv -s script.js -o output
    cmd = [
        "ffedit",
        "-i",
        str(input_path),
        "-f",
        "mv",  # motion vectors feature
        "-s",
        str(script_path),
        "-o",
        str(output_path),
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        # FFglitch may output warnings that aren't fatal
        if not output_path.exists():
            raise RuntimeError(f"ffedit failed: {result.stderr}")

    return output_path


def _finalize_video(
    processed_path: Path,
    original_path: Path,
    output_path: Path,
    preview: PreviewSettings | None = None,
) -> Path:
    """Re-encode processed video and optionally add back audio.

    Args:
        processed_path: Video processed by FFglitch
        original_path: Original input video (for audio)
        output_path: Final output path
        preview: Preview settings for encoding quality

    Returns:
        Path to final video
    """
    crf = preview.crf if preview else 18

    # Check if original has audio
    probe_cmd = [
        "ffprobe",
        "-v", "error",
        "-select_streams", "a:0",
        "-show_entries", "stream=codec_type",
        "-of", "csv=p=0",
        str(original_path),
    ]
    probe_result = subprocess.run(probe_cmd, capture_output=True, text=True)
    has_audio = "audio" in probe_result.stdout

    cmd = [
        "ffmpeg",
        "-y",
        "-i",
        str(processed_path),
    ]

    if has_audio:
        cmd.extend(["-i", str(original_path)])

    cmd.extend([
        "-c:v",
        "libx264",
        "-crf",
        str(crf),
        "-pix_fmt",
        "yuv420p",
    ])

    if has_audio:
        cmd.extend([
            "-map", "0:v:0",
            "-map", "1:a:0",
            "-c:a", "aac",
            "-shortest",
        ])

    cmd.append(str(output_path))

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        raise RuntimeError(f"FFmpeg finalization failed: {result.stderr}")

    return output_path


# Legacy functions kept for API compatibility
def extract_motion_vectors(input_path: Path | str, output_path: Path | str) -> Path:
    """Extract motion vectors from video to JSON using ffedit.

    Note: FFglitch 0.10.x uses -e flag for JSON export without format specifier.

    Args:
        input_path: Path to input video
        output_path: Path for output JSON file with motion vectors

    Returns:
        Path to the motion vector JSON file
    """
    input_path = Path(input_path)
    output_path = Path(output_path)

    # ffedit -i input.mp4 -e output.json exports frame data
    cmd = [
        "ffedit",
        "-i",
        str(input_path),
        "-e",
        str(output_path),
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        raise RuntimeError(f"ffedit export failed: {result.stderr}")

    return output_path


def apply_motion_vectors(
    input_path: Path | str,
    vectors_path: Path | str,
    output_path: Path | str,
) -> Path:
    """Apply motion vectors from JSON to video.

    Note: FFglitch 0.10.x uses -a flag for applying JSON data.

    Args:
        input_path: Original video
        vectors_path: JSON file with motion vectors
        output_path: Path for output video

    Returns:
        Path to the output video
    """
    input_path = Path(input_path)
    vectors_path = Path(vectors_path)
    output_path = Path(output_path)

    # ffedit -i input.mp4 -a vectors.json -o output.mp4
    cmd = [
        "ffedit",
        "-i",
        str(input_path),
        "-a",
        str(vectors_path),
        "-o",
        str(output_path),
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        raise RuntimeError(f"ffedit apply failed: {result.stderr}")

    return output_path


def load_motion_vectors(path: Path | str) -> list[np.ndarray]:
    """Load motion vectors from FFglitch JSON file.

    FFglitch JSON format has frames with mv arrays containing
    macroblock data with fwd/bwd motion vectors.

    Args:
        path: Path to motion vector JSON file

    Returns:
        List of numpy arrays, one per frame
    """
    path = Path(path)
    with open(path) as f:
        data = json.load(f)

    frames = []
    for frame_data in data.get("frames", []):
        mv = frame_data.get("mv", [])
        if mv:
            # Flatten the macroblock structure to a simple array
            flat_vectors = []
            for row in mv:
                if not row:
                    continue
                for mb in row:
                    if not mb:
                        continue
                    fwd = mb.get("fwd", [])
                    for vec in fwd:
                        if vec:
                            flat_vectors.append(vec)
            frames.append(np.array(flat_vectors) if flat_vectors else np.array([]))
        else:
            frames.append(np.array([]))

    return frames


def save_motion_vectors(frames: list[np.ndarray], path: Path | str) -> None:
    """Save motion vectors to FFglitch-compatible JSON file.

    Note: This creates a simplified structure. For full round-trip
    compatibility, use the scripting approach instead.

    Args:
        frames: List of numpy arrays with motion vectors
        path: Output path for JSON file
    """
    path = Path(path)

    data = {"frames": [{"mv": frame.tolist() if len(frame) > 0 else []} for frame in frames]}

    with open(path, "w") as f:
        json.dump(data, f)


def apply_vector_transform(
    input_path: Path | str,
    output_path: Path | str,
    transform: VectorTransform | str,
    preview: PreviewSettings | None = None,
    **transform_kwargs,
) -> Path:
    """Apply a transform to motion vectors using FFglitch JavaScript scripting.

    This function uses FFglitch's native JavaScript scripting capability to
    transform motion vectors during video processing. The workflow is:
    1. Convert input to MPEG-4 (compatible with FFglitch MV access)
    2. Generate a JavaScript script for the requested transform
    3. Run ffedit with the script to process the video
    4. Re-encode to H.264 and optionally restore audio

    Args:
        input_path: Path to input video
        output_path: Path for output video
        transform: Transform function or name of built-in transform
        preview: Preview settings for fast rendering
        **transform_kwargs: Arguments to pass to the transform function

    Returns:
        Path to the output video
    """
    input_path = Path(input_path)
    output_path = Path(output_path)

    if not check_ffglitch_installed():
        raise RuntimeError(
            "FFglitch tools (ffedit, ffgac) not found. Please install from https://ffglitch.org/"
        )

    # Determine transform name
    if isinstance(transform, str):
        transform_name = transform
    else:
        # For callable transforms, we need to use the legacy approach
        # or map to a known transform name
        transform_name = getattr(transform, "__name__", "jitter")

    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        # Step 1: Prepare video (convert to MPEG-4 for FFglitch compatibility)
        prepared_input = tmpdir / "prepared.mp4"
        _prepare_video_for_ffglitch(input_path, prepared_input, preview)

        # Step 2: Generate JavaScript transform script
        script_content = _generate_transform_script(transform_name, transform_kwargs)
        script_path = tmpdir / "transform.js"
        with open(script_path, "w") as f:
            f.write(script_content)

        # Step 3: Run FFglitch with the script
        processed_output = tmpdir / "processed.mp4"
        _run_ffglitch_script(prepared_input, processed_output, script_path)

        # Step 4: Finalize (re-encode and restore audio)
        _finalize_video(processed_output, input_path, output_path, preview)

    return output_path


def apply_expression(
    input_path: Path | str,
    output_path: Path | str,
    expression: str,
    preview: PreviewSettings | None = None,
) -> Path:
    """Apply an inline expression to motion vectors.

    Converts Python-style expressions to FFglitch JavaScript and applies them.

    Supported expression patterns:
    - "frame[:,:,0] *= 2"  # Double horizontal motion
    - "frame[:,:,1] = 0"   # Kill vertical motion
    - "frame[:,:,0] += 5"  # Add offset to horizontal motion

    Args:
        input_path: Path to input video
        output_path: Path for output video
        expression: Python-style expression to apply
        preview: Preview settings

    Returns:
        Path to the output video
    """
    input_path = Path(input_path)
    output_path = Path(output_path)

    if not check_ffglitch_installed():
        raise RuntimeError(
            "FFglitch tools (ffedit, ffgac) not found. Please install from https://ffglitch.org/"
        )

    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        # Prepare video
        prepared_input = tmpdir / "prepared.mp4"
        _prepare_video_for_ffglitch(input_path, prepared_input, preview)

        # Generate JavaScript from expression
        script_content = _generate_expression_script(expression)
        script_path = tmpdir / "expression.js"
        with open(script_path, "w") as f:
            f.write(script_content)

        # Run FFglitch
        processed_output = tmpdir / "processed.mp4"
        _run_ffglitch_script(prepared_input, processed_output, script_path)

        # Finalize
        _finalize_video(processed_output, input_path, output_path, preview)

    return output_path


def apply_script(
    input_path: Path | str,
    output_path: Path | str,
    script_path: Path | str,
    preview: PreviewSettings | None = None,
) -> Path:
    """Apply a custom JavaScript script to motion vectors.

    The script should define a glitch_frame(frame, stream) function that
    FFglitch will call for each frame. Motion vectors are accessible via
    frame["mv"] which contains an array of macroblock rows.

    Example script:
        export function glitch_frame(frame, stream) {
            var mv = frame["mv"];
            if (!mv) return;

            for (var i = 0; i < mv.length; i++) {
                var row = mv[i];
                if (!row) continue;
                for (var j = 0; j < row.length; j++) {
                    var mb = row[j];
                    if (mb && mb["fwd"]) {
                        for (var k = 0; k < mb["fwd"].length; k++) {
                            var vec = mb["fwd"][k];
                            if (vec) {
                                vec[0] *= 2;  // Double horizontal motion
                            }
                        }
                    }
                }
            }
        }

    Args:
        input_path: Path to input video
        output_path: Path for output video
        script_path: Path to JavaScript script (not Python)
        preview: Preview settings

    Returns:
        Path to the output video
    """
    input_path = Path(input_path)
    output_path = Path(output_path)
    script_path = Path(script_path)

    if not check_ffglitch_installed():
        raise RuntimeError(
            "FFglitch tools (ffedit, ffgac) not found. Please install from https://ffglitch.org/"
        )

    if not script_path.exists():
        raise FileNotFoundError(f"Script not found: {script_path}")

    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        # Prepare video
        prepared_input = tmpdir / "prepared.mp4"
        _prepare_video_for_ffglitch(input_path, prepared_input, preview)

        # Run FFglitch with user's script
        processed_output = tmpdir / "processed.mp4"
        _run_ffglitch_script(prepared_input, processed_output, script_path)

        # Finalize
        _finalize_video(processed_output, input_path, output_path, preview)

    return output_path
